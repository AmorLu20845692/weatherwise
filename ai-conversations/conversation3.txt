Data Visualization Design and Implementation

Me: I need to create two different types of weather visualizations for my WeatherWise project. The assignment requires temperature and precipitation visualizations that are clear, properly labeled, and informative. Can you help me design effective weather charts?

AI: Absolutely! Weather visualizations are crucial for helping users understand complex meteorological data at a glance. Let me help you create two compelling visualization types that will make your WeatherWise app stand out.

**For Weather Visualizations, Consider:**
1. **User Context**: What decisions will users make based on this data?
2. **Data Density**: How to show multiple days without cluttering
3. **Visual Hierarchy**: Most important information should be most prominent
4. **Color Psychology**: Blues for cold/rain, reds for hot, etc.

Let's start with the temperature visualization:

```python
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime

def create_temperature_visualisation(weather_data, output_type='display'):
    """
    Create visualisation of temperature data.
    """
    if 'error' in weather_data:
        print(f"Cannot create visualization: {weather_data['error']}")
        return None
    
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Prepare data
    dates = []
    max_temps = []
    min_temps = []
    avg_temps = []
    
    for day in weather_data['forecast']:
        try:
            date_obj = datetime.strptime(day['date'], '%Y-%m-%d')
            dates.append(date_obj)
            max_temps.append(day['max_temp'])
            min_temps.append(day['min_temp'])
            avg_temps.append(day['avg_temp'])
        except ValueError:
            continue
    
    # Create the plot with multiple data series
    ax.plot(dates, max_temps, 'r-o', label='Max Temperature', linewidth=2, markersize=6)
    ax.plot(dates, min_temps, 'b-o', label='Min Temperature', linewidth=2, markersize=6)
    ax.plot(dates, avg_temps, 'g-o', label='Average Temperature', linewidth=2, markersize=6)
    
    # Fill between max and min temperatures for visual impact
    ax.fill_between(dates, min_temps, max_temps, alpha=0.3, color='orange')
    
    # Professional styling
    ax.set_title(f'Temperature Forecast for {weather_data["location"]}', 
                fontsize=16, fontweight='bold')
    ax.set_xlabel('Date', fontsize=12)
    ax.set_ylabel('Temperature (°C)', fontsize=12)
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=10)
    
    # Format dates on x-axis
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
    ax.xaxis.set_major_locator(mdates.DayLocator())
    plt.xticks(rotation=45)
    
    # Add current temperature reference line
    current_temp = weather_data['current'].get('temperature', 0)
    if current_temp > 0:
        ax.axhline(y=current_temp, color='red', linestyle='--', alpha=0.7, 
                  label=f'Current: {current_temp}°C')
        ax.legend(fontsize=10)
    
    plt.tight_layout()
    
    if output_type == 'figure':
        return fig
    else:
        plt.show()
```

**What makes this temperature visualization effective:**

1. **Multiple Data Series**: Shows max, min, and average temperatures
2. **Visual Range**: Fill between max/min shows temperature range clearly
3. **Current Context**: Horizontal line shows current temperature for reference
4. **Professional Styling**: Clean, readable fonts and colors
5. **Date Formatting**: Clear date labels that don't overlap

Now for the precipitation visualization - this one is trickier because precipitation data can be sparse:

Me: This looks great! I especially like the fill between max and min temperatures - that really helps show the daily temperature range. For the precipitation chart, I'm thinking it should handle both daily totals and maybe hourly data if available. What do you think?

AI: Excellent thinking! Precipitation visualization is more complex because it often involves sparse data and different time scales. A dual-chart approach showing both daily totals and hourly detail would be perfect. Here's my recommendation:

```python
def create_precipitation_visualisation(weather_data, output_type='display'):
    """
    Create visualisation of precipitation data with daily and hourly views.
    """
    if 'error' in weather_data:
        print(f"Cannot create visualization: {weather_data['error']}")
        return None
    
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
    
    # Prepare daily precipitation data
    dates = []
    precipitation = []
    
    for day in weather_data['forecast']:
        try:
            date_obj = datetime.strptime(day['date'], '%Y-%m-%d')
            dates.append(date_obj)
            precipitation.append(day['precipitation'])
        except ValueError:
            continue
    
    # Top plot: Daily precipitation bar chart
    bars = ax1.bar(dates, precipitation, color='skyblue', alpha=0.7, edgecolor='navy')
    ax1.set_title(f'Precipitation Forecast for {weather_data["location"]}', 
                 fontsize=16, fontweight='bold')
    ax1.set_ylabel('Precipitation (mm)', fontsize=12)
    ax1.grid(True, alpha=0.3, axis='y')
    
    # Add value labels on bars for easy reading
    for bar, precip in zip(bars, precipitation):
        if precip > 0:
            ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                    f'{precip:.1f}mm', ha='center', va='bottom', fontsize=10)
    
    # Format dates
    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
    ax1.xaxis.set_major_locator(mdates.DayLocator())
    
    # Bottom plot: Hourly precipitation for first day (most relevant)
    if weather_data['forecast'] and weather_data['forecast'][0].get('hourly_precip'):
        hourly_precip = weather_data['forecast'][0]['hourly_precip']
        hours = list(range(0, len(hourly_precip) * 3, 3))  # 3-hour intervals
        
        ax2.plot(hours, hourly_precip, 'o-', color='blue', linewidth=2, markersize=6)
        ax2.fill_between(hours, hourly_precip, alpha=0.3, color='lightblue')
        ax2.set_title(f'Hourly Precipitation - {weather_data["forecast"][0]["date"]}', fontsize=14)
        ax2.set_xlabel('Hour of Day', fontsize=12)
        ax2.set_ylabel('Precipitation (mm)', fontsize=12)
        ax2.grid(True, alpha=0.3)
        ax2.set_xlim(0, 21)
        
        # Add intensity indicator
        max_precip = max(hourly_precip) if hourly_precip else 0
        if max_precip > 10:
            intensity = "Heavy Rain"
            color = "red"
        elif max_precip > 2.5:
            intensity = "Moderate Rain"
            color = "orange"
        elif max_precip > 0.1:
            intensity = "Light Rain"
            color = "green"
        else:
            intensity = "No Rain"
            color = "gray"
        
        ax2.text(0.02, 0.98, f'Intensity: {intensity}', transform=ax2.transAxes,
                fontsize=12, fontweight='bold', color=color,
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
    
    else:
        ax2.text(0.5, 0.5, 'Hourly precipitation data not available', 
                transform=ax2.transAxes, ha='center', va='center', fontsize=12)
    
    plt.tight_layout()
    
    if output_type == 'figure':
        return fig
    else:
        plt.show()
```

**What makes this precipitation visualization powerful:**

1. **Dual Perspective**: Daily overview + hourly detail for immediate planning
2. **Smart Data Labels**: Shows exact amounts only when significant
3. **Intensity Classification**: Color-coded intensity levels help users understand impact
4. **Graceful Degradation**: Handles missing hourly data elegantly
5. **Visual Hierarchy**: Bar chart for totals, line chart for timing

**Key Design Principles Applied:**

- **Progressive Disclosure**: Overview first, then detail
- **Contextual Information**: Intensity labels help interpret raw numbers
- **Zero-Baseline**: Bar charts start at zero for accurate visual comparison
- **Color Meaning**: Blues for water, intensity colors for warnings

This dual-chart approach gives users both the "how much" and "when" information they need for planning activities!

Me: This is fantastic! I love the dual-chart approach and the intensity classification. One question - should I be concerned about the 3-hour intervals for hourly data? That seems like it might not actually be hourly.

AI: Great catch! You're absolutely right to question that. The term "hourly" is misleading when we're actually dealing with 3-hour intervals. This is actually a common issue with weather APIs - many provide data in 3-hour or 6-hour chunks rather than true hourly data.

Let me fix the terminology and make it more accurate:

```python
# Instead of calling it "hourly" everywhere, let's be precise:

# Bottom plot: Detailed precipitation timing for today
if weather_data['forecast'] and weather_data['forecast'][0].get('hourly_precip'):
    precip_data = weather_data['forecast'][0]['hourly_precip']
    
    # Determine the actual interval (usually 3 hours for wttr.in)
    interval_hours = 24 // len(precip_data) if len(precip_data) > 0 else 3
    hours = list(range(0, 24, interval_hours))
    
    ax2.plot(hours, precip_data, 'o-', color='blue', linewidth=2, markersize=6)
    ax2.fill_between(hours, precip_data, alpha=0.3, color='lightblue')
    
    # More accurate title
    ax2.set_title(f'Precipitation Throughout the Day - {weather_data["forecast"][0]["date"]}', fontsize=14)
    ax2.set_xlabel(f'Hour of Day ({interval_hours}h intervals)', fontsize=12)
    ax2.set_ylabel('Precipitation (mm)', fontsize=12)
    
    # Set x-axis to show all 24 hours but mark actual data points
    ax2.set_xlim(0, 23)
    ax2.set_xticks(hours)
    ax2.set_xticklabels([f'{h:02d}:00' for h in hours])
```

**Why this is better:**

1. **Honest Labeling**: Clearly shows the actual time intervals
2. **Accurate Expectations**: Users understand the resolution of the data
3. **Flexible Design**: Works whether API provides 3h, 6h, or actual 1h data
4. **Professional Standards**: Weather apps should be precise about data resolution

**Additional Improvement - Add Data Source Note:**
```python
# Add a small note about data resolution
ax2.text(0.98, 0.02, f'Data resolution: {interval_hours} hours', 
         transform=ax2.transAxes, ha='right', va='bottom', 
         fontsize=9, style='italic', alpha=0.7)
```

This kind of attention to accuracy and honest data presentation is exactly what distinguishes a professional weather application from a basic one. It shows you understand the limitations of your data source and communicate them clearly to users.

Great eye for detail!

Me: Perfect! That's much more honest and professional. I really appreciate how you've helped me think about both the technical implementation and the user experience aspects of data visualization.